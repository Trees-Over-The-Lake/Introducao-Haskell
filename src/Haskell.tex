\documentclass[
	% -- opções da classe memoir --
	article,			% indica que é um artigo acadêmico
	11pt,				% tamanho da fonte
	oneside,			% para impressão apenas no recto. Oposto a twoside
	a4paper,			% tamanho do papel. 
	% -- opções da classe abntex2 --
	%chapter=TITLE,		% títulos de capítulos convertidos em letras maiúsculas
	%section=TITLE,		% títulos de seções convertidos em letras maiúsculas
	%subsection=TITLE,	% títulos de subseções convertidos em letras maiúsculas
	%subsubsection=TITLE % títulos de subsubseções convertidos em letras maiúsculas
	% -- opções do pacote babel --
	english,			% idioma adicional para hifenização
	brazil,				% o último idioma é o principal do documento
	sumario=tradicional
	]{abntex2}
% ---
% Pacotes fundamentais 
% ---
\usepackage{lmodern}			% Usa a fonte Latin Modern
\usepackage[T1]{fontenc}		% Selecao de codigos de fonte.
\usepackage[utf8]{inputenc}		% Codificacao do documento (conversão automática dos acentos)
\usepackage{indentfirst}		% Indenta o primeiro parágrafo de cada seção.
\usepackage{color}				% Controle das cores
\usepackage{graphicx}			% Inclusão de gráficos
\usepackage{microtype} 			% para melhorias de justificação
% ---

% ---
% Pacotes adicionais, usados apenas no âmbito do Modelo Canônico do abnteX2
% ---
\usepackage{lipsum}				% para geração de dummy text
% ---

% Definindo a formatação do listing de codigo
\usepackage{listings}

% ---
% Pacotes de citações
% ---
\usepackage[brazilian,hyperpageref]{backref}	 % Paginas com as citações na bibl
\usepackage[alf]{abntex2cite}	% Citações padrão ABNT

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{gray}{0.6}

\lstdefinestyle{mystyle}{
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2
}

\lstset{style=mystyle}

% O tamanho do parágrafo é dado por:
\setlength{\parindent}{1.3cm}

% Controle do espaçamento entre um parágrafo e outro:
\setlength{\parskip}{0.2cm}  % tente também \onelineskip


\titulo{Uma Introdução a Haskell}
\autor{Gustavo Lopes Rodrigues \and Lucas Santiago \and Pedro Souza \and Thiago Henriques}
\local{Belo Horizonte}
\data{2020}
\instituicao{%
  Pontifícia Universidade Católica Minas Gerais
  }
\tipotrabalho{Trabalho de LIP}

\begin{document} 

    \selectlanguage{brazil}

    \frenchspacing

    \imprimircapa

    \tableofcontents*

    \textual

    \chapter{Introdução}

    Em 1930, Alonzo Church , matemático estadunidense apresentou o Cálculo Lambda, como parte da investigação dos fundamentos da matemática. O Cálculo Lambda é um sistema que
    estuda funções recursivas computáveis, e foi utilizada como base para as teorias e fundamentos matemáticos por trás do paradigma da Programação Funcional. Ele também
    pode ser considerado a primeira linguagem programação funcional, todavia, não foi projetada para ser executada em computadores, sendo apenas um modelo que descreve relações entre funções
    simples, permitindo criar funções mais complexas.

    Com o passar dos anos, varias linguagens funcionais foram criadas, sendo alguns exemplos a linguagem LISP em 1955 e a ML no final da década de 70. Porém, não
    havia um padrão para as linguagens desse paradigma, e quando chegou a segunda metade da década de 80, havia uma necessidade para criar uma única linguagem, que englobasse
    as melhores práticas de projeto, além de implementar as técnicas funcionais que estavam em alta na época.

    Em Setembro de 1987, aconteceu a conferência \emph{Functional Programming Language and Computer Architecture} em Portland - Oregon, para que fosse discutido justamente
    tais questões.

    Dessa conferência, surgiu as seguintes diretrizes:
    \begin{itemize}
      \item Ser viável para o ensino, pesquisa e aplicações, incluindo sistema de larga escala;
      \item Ser completamente descritiva via publicação no tocante à sua sintaxe e sua semântica;
      \item Não ser proprietária, tal que qualquer um pudesse implementá-la e distribuí-la;
      \item Basear-se em ideias que envolvessem o senso comum;
      \item Reduzir a diversidade desnecessária de outras linguagens funcionais.
    \end{itemize}

    Além disso, eles decidiram não começar do zero, e elegeu a linguagem Miranda, como base do projeto, por ser a mais amadurecida e bem projetada entre as demais. E 
    foi a partir dessa linguagem, que nasceu Haskell.

    \chapter{Histórico sobre a linguagem, com sua cronologia}

    Como dito anteriormente, Haskell nasceu a partir da necessidade de criar uma linguagem funcional mais padronizada. Seu nome é uma homenagem ao 
    matemático Haskell Brooks Curry, que contribuiu com teorias fundamentais para o paradigma.

    A primeira versão foi definida em 1 de abril de 1990 e com o passar dos anos, a linguagem foi recebendo atualizações(1.1 em 1991, 1.2 em 1992, 1.3 em 1996 e 1.4 em 1997). 
    Em janeiro de 1999, foi juntado todos as versões anteriores para fazer o Haskell 98, que especifíca uma versão mínima, estável e portável da linguagem e das bibliotecas para ensino. 
    A linguagem mesmo assim continuo evoluindo, recebendo novas atualizações em 2003, 2006 e por fim , a última atualização em
    2010, com o Haskell 2010.

    \chapter{Paradigma a que pertence}

    O paradigma oferece e determina a visão que o programador possui sobre a estruturação
    e a execução do programa. Um exemplo bem famoso de paradigma é o POO ( Programação orientada a objetos).
    Já a Programação funcional é um paradigma que descreve uma expressão matemática a ser avaliada,
    mapeando dos valores de entradas nos valores de retorno, por meio de funções. Em outras palavras: 
    a programação funcional só funciona em cima de funções.

    Eis mais algumas características do paradigma
    \begin{itemize}
      \item Dados imutáveis e são evitados estados. 
      \item Não existe efeitos colaterais 
      \item "Funções puras" (sem efeitos colaterais)
      \item Cálculo Lambda
    \end{itemize}

    \chapter{Características mais marcantes da linguagem}

    \begin{itemize}
      \item Como dito anteriormente, a linguagem só faz utilização de funções e funções dentro de funções. Por isso
      Haskell é descrito como puramente funcional.
      \item Haskell possui uma sintaxe simples, elegante e concisa. Como resultado, programas em Haskell possuem 
      poucas linhas. 
      \item Além disso, a linguagem usa avaliação preguiçosa(Lazy evaluation), que é uma técnica para atrasar a computação 
      até um ponto em que o resultado da computação é considerado necessário.
      \item Tipagem estática: Verificação dos tipos usados em dados e variáveis para 
      garantir que sempre está sendo usado um tipo que é esperado em todas as situações. 
      \item função de ordem superior: Função que tem como argumento uma outra função, ou que produz 
      uma função como resultado.
    \end{itemize}

    \chapter{Linguagem similares ou confrontantes}

    \begin{itemize}
      \item Prolog
      \item LISP 
      \item Scheme 
      \item ML 
      \item Miranda 
      \item Elixir 
    \end{itemize}

    \chapter{Exemplo(s) de programa(s)}

    \subsection*{Hello World em Haskell}
      \lstinputlisting[language=haskell]{helloworld.hs}

    \subsection*{Quicksort}
      Exemplo de Quicksort em C: \newline
      \lstinputlisting[language=c]{quicksort.c}
      Exemplo de Quicksort em Haskell usando compreensão de lista \newline
      \lstinputlisting[language=haskell]{quicksort_list.hs}      
      Exemplo de Quicksort em Haskell usando a função filter: \newline
      \lstinputlisting[language=haskell]{quicksort_filter.hs}

      \subsection*{Explicação dos algoritmos}
      Os algoritmos em Haskell são extremamente compactos em relação à C. Sua sintaxe não tem foco
      em programar diretamente a memória, como acontece em C. Começando pelo \emph{Hello World} simples que possui ou evoluindo
      para um quicksort, a lingua mostra-se bem compacta e direta na resolução do problema.

      No primeiro exemplo, foi usado \emph{list comprehension} para resolver o problema. Na primeira linha,
      foi declarado uma lista vazia, mas poderia ser uma lista contendo quaisquer valores. A segunda linha
      cria uma função recursiva e 

      aSDASDASD ASD ASD ASD AS DAExemplo de Quicksort em Haskell usando a função filter: \newline
      \lstinputlisting[language=haskell]{quicksort_c2haskell.hs}
      ASDASDAS DASD ASD ASD ASExemplo de Quicksort em Haskell usando a função filter: \newline
      \lstinputlisting[language=haskell]{quicksort_c2Haskellresumido.hs}

    \chapter{Estudo de Caso, sobre o(s) tema(s)}
    \chapter{Considerações finais}

    \begin{apendicesenv}

        \partapendices
        \chapter{Teste}
    
    \end{apendicesenv}

\end{document}


